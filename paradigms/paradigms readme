Домашнее задание 1. Обработка ошибок

    Добавлена обработка ошибок, в том числе:
        ошибки разбора выражений;
        ошибки вычисления выражений.
    Для выражения 1000000*x*x*x*x*x/(x-1) вывод программы имеет следующий вид:

    x       f
    0       0
    1       division by zero
    2       32000000
    3       121500000
    4       341333333
    5       overflow
    6       overflow
    7       overflow
    8       overflow
    9       overflow
    10      overflow
                

    Результат division by zero (overflow) означает, что в процессе вычисления произошло деление на ноль (переполнение).
    Человеко-читаемые сообщения об ошибках выводятся на консоль.
    Программа не «вылетает» с исключениями (как стандартными, так и добавленными). 
    
Домашнее задание 2. Бинарный поиск

    Реализован итеративный и рекурсивный варианты бинарного поиска в массиве.
    На вход подается целое число x и массив целых чисел a, отсортированный по невозрастанию. Находится минимальное значение индекса i, при котором a[i] <= x.
    Для main, функций бинарного поиска и вспомогательных функций указаны, пред- и постусловия. Для реализаций методов приведены доказательства соблюдения контрактов в терминах троек Хоара.
    Интерфейс программы.
        Имя основного класса — search.BinarySearch.
        Первый аргумент командной строки — число x.
        Последующие аргументы командной строки — элементы массива a.
    Пример запуска: java search.BinarySearch 3 5 4 3 2 1. Ожидаемый результат: 2. 

Домашнее задание 3. Очередь на массиве

    Определена модель и найден инвариант структуры данных «очередь». Определены функции, которые необходимы для реализации очереди. Найдены их пред- и постусловия, при условии что очередь не содержит null.
    Реализованы классы, представляющие циклическую очередь на основе массива.
        Класс ArrayQueueModule реализовывает один экземпляр очереди с использованием переменных класса.
        Класс ArrayQueueADT реализовывает очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
        Класс ArrayQueue должен реализовывает очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
        Реализованы следующие функции (процедуры) / методы:
            enqueue – добавить элемент в очередь;
            element – первый элемент в очереди;
            dequeue – удалить и вернуть первый элемент в очереди;
            size – текущий размер очереди;
            isEmpty – является ли очередь пустой;
            clear – удалить все элементы из очереди.
        Модель, инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.

Домашнее задание 4. Очереди

    Определен интерфейс очереди Queue и описан его контракт.
    Реализован класс LinkedQueue — очередь на связном списке.
    Выделены общие части классов LinkedQueue и ArrayQueue в базовый класс AbstractQueue. 

Домашнее задание 5. Вычисление в различных типах

В программу разбирающую и вычисляющую выражения трех переменных добавлена поддержка вычисления в различных типах.

    Создан класс expression.generic.GenericTabulator, реализующий интерфейс expression.generic.Tabulator:

        public interface Tabulator {
            Object[][][] tabulate(
                String mode, String expression, 
                int x1, int x2, int y1, int y2, int z1, int z2
            ) throws Exception;
        }
                

    Аргументы
        mode — режим работы
        Режим	Тип
        i	int с детекцией переполнений
        d	double
        bi	BigInteger
        expression — вычисляемое выражение;
        x1, x2; y1, y2; z1, z2 — диапазоны изменения переменных (включительно). 

    Возвращаемое значение — таблица значений функции, где R[i][j][k] соответствует x = x1 + i, y = y1 + j, z = z1 + k. Если вычисление завершилось ошибкой, в соответствующей ячейке null.
    Реализация не содержит непроверяемых преобразований типов.
    Реализация не должна использует аннотацию @SuppressWarnings.

Домашнее задание 6. Функциональные выражения на JavaScript

    Разработаны функции cnst, variable, add, subtract, multiply, divide, negate для вычисления выражений с тремя переменными: x, y и z.
    Функции позволяют производить вычисления вида:

    let expr = subtract(
        multiply(
            cnst(2),
            variable("x")
        ),
        cnst(3)
    );

    println(expr(5, 0, 0));
                

    При вычислении выражения вместо каждой переменной подставляется значение, переданное в качестве соответствующего параметра функции expr. Таким образом, результатом вычисления приведенного примера является число 7.

    При выполнении задания обращено внимание на:
        Применение функций высшего порядка.
        Выделение общего кода для операций.

Домашнее задание 7. Объектные выражения на JavaScript

    Разработаны классы Const, Variable, Add, Subtract, Multiply, Divide, Negate для представления выражений с тремя переменными: x, y и z.
        Пример описания выражения 2x-3:

        let expr = new Subtract(
            new Multiply(
                new Const(2),
                new Variable("x")
            ),
            new Const(3)
        );

        println(expr.evaluate(5, 0, 0));
                            

        При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода evaluate. Таким образом, результатом вычисления приведенного примера является число 7.
        Метод toString() должен выдавать запись выражения в обратной польской записи. Например, expr.toString() должен выдавать «2 x * 3 -». 
    Функция parse выдаёт разобранное объектное выражение.
    
    При выполнении задания обращено внимание на:
        Применение инкапсуляции.
        Выделение общего кода для операций.
        Минимизацию необходимой памяти.

Домашнее задание 8. Обработка ошибок на JavaScript

    В предыдущее задание добавлена функция parsePrefix(string), разбирающая выражения, задаваемые записью вида «(- (* 2 x) 3)». Если разбираемое выражение некорректно, метод parsePrefix бросает человеко-читаемое сообщение об ошибке.
    В предыдущее задание добавлен метод prefix(), выдающий выражение в формате, ожидаемом функцией parsePrefix.
    При выполнении задания обращено внимание на:
        Применение инкапсуляции.
        Выделение общего кода для операций.
        Минимизацию необходимой памяти.
        Обработку ошибок.

Домашнее задание 9. Линейная алгебра на Clojure

    Разработаны функции для работы с объектами линейной алгебры, которые представляются следующим образом:
        скаляры – числа
        векторы – векторы чисел;
        матрицы – векторы векторов чисел.
    Функции над векторами:
        v+/v-/v*/vd – покоординатное сложение/вычитание/умножение/деление;
        scalar/vect – скалярное/векторное произведение;
        v*s – умножение на скаляр. 
    Функции над матрицами:
        m+/m-/m*/md – поэлементное сложение/вычитание/умножение/деление;
        m*s – умножение на скаляр;
        m*v – умножение на вектор;
        m*m – матричное умножение;
        transpose – транспонирование; 
    При выполнении задания обращено внимание на:
        Применение функций высшего порядка.
        Выделение общего кода для операций.

Домашнее задание 10. Функциональные выражения на Clojure

    Разработаны функции constant, variable, add, subtract, multiply, divide и negate для представления арифметических выражений.
        Пример описания выражения 2x-3:

        (def expr
          (subtract
            (multiply
              (constant 2)
              (variable "x"))
            (constant 3)))
                            

        Выражение является функцией, возвращающей значение выражения при подстановке переменных, заданных отображением. Например, (expr {"x" 2}) равно 1. 
    Разработан разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,

    (parseFunction "(- (* 2 x) 3)")

    эквивалентно expr.
    При выполнении задания обращено внимание на:
        Выделение общего кода для операций. 

Домашнее задание 11. Объектные выражения на Clojure

    Разработаны конструкторы Constant, Variable, Add, Subtract, Multiply, Divide и Negate для представления арифметических выражений.
        Пример описания выражения 2x-3:

        (def expr
          (Subtract
            (Multiply
              (Constant 2)
              (Variable "x"))
            (Constant 3)))
                            

        Функция (evaluate expression vars) производит вычисление выражения expression для значений переменных, заданных отображением vars. Например, (evaluate expr {"x" 2}) должно быть равно 1.
        Функция (toString expression) выдаёт запись выражения в стандартной для Clojure форме.
        Функция (parseObject "expression") разбирает выражения, записанные в стандартной для Clojure форме. Например,

        (parseObject "(- (* 2 x) 3)")

        эквивалентно expr.
        Функция (diff expression "variable") возвращает выражение, представляющее производную исходного выражения по заданой перемененной. Например, (diff expression "x") возвращает выражение, эквивалентное (Constant 2), при этом выражения (Subtract (Constant 2) (Constant 0)) и

        (Subtract
          (Add
            (Multiply (Constant 0) (Variable "x"))
            (Multiply (Constant 2) (Constant 1)))
          (Constant 0))
                            

        так же считаются правильным ответом. 
 
Домашнее задание 12. Комбинаторные парсеры

    Простой вариант. Реализована функция (parseObjectSuffix "expression"), разбирающая выражения, записанные в суффиксной форме, и функция toStringSuffix, возвращающая строковое представление выражения в этой форме. Например,

    (toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))

    возвращает ((2 x *) 3 -).
    

Домашнее задание 13. Простые числа на Prolog

    Разработаны правила:
        prime(N), проверяющее, что N – простое число.
        composite(N), проверяющее, что N – составное число.
        prime_divisors(N, Divisors), проверяющее, что список Divisors содержит все простые делители числа N, упорядоченные по возрастанию. Если N делится на простое число P несколько раз, то Divisors должен содержать соответствующее число копий P. 
    Рассчитывается, что до первого запроса будет выполнено правило init(MAX_N). 
