# HW6 (Golang) - Concurrency factorization

## Конкурентная факоризация чисел

### Дан следующий фрагмент кода

`internal/fact/fact.go`

```golang
type Input struct {
	NumsOfGoroutine int   // n - число горутин
	Numbers         []int // слайс чисел, которые необходимо факторизовать
}

type Factorization interface {
	Work(Input, io.Writer) error
}

func NewFactorization() /*your type*/ {}
```

Запрещается в приведённом фрагменте кода:

* Менять сигнатуры;
* Менять модификаторы доступа;


### Задание

Программе подаётся список чисел и число `n`. Необходимо посчитать факторизацию (факторизация числа - разложение числа
на произведение его простых множителей) для каждого числа в списке и вывести в консоль в том порядке в котором они были
обработаны (т.е. порядок вывода может не совпадать с исходным порядком чисел в списке). Обработка чисел должна
происходить в `n` потоков. Вывод в консоль должен происходить конкурентно. Вывод в консоль не должен блокироваться
обработкой соседних чисел (т.е. если для факторизации числа `a` требуется `10s`, а для `b` требуется `1s` и исходный
список `a, b, b` и потоков > 1, то вывод для `b` должен быть напечатан сразу раньше чем для `a` - сразу после
обработки `b`)

### Формат:

* Простые множители записываем от меньшего к большему;
* Если число меньше нуля - добавляем множитель `-1` и обрабатываем как натуральное;
* Каждая строка вывод должна быть инкрементально пронумерована сквозной нумерацией с `1`;

### Пример:

#### Input:

`[100, -17, 25, 38], 3`

#### Output:
```text
line 1, 100 = 2 * 2 * 5 * 5
line 2, -17 = -1 * 17
line 3, 38 = 2 * 19
line 4, 25 = 5 * 5
```
Пояснение: номер линии и факторизация

#### Тесты

* Напишите тесты, покрывающие функциональность.
* Свои тесты разместите в `fact_test.go`


### Как сдавать:

* Проверить, что появился **ваш личный** репозиторий с `HW6`, сделать его клон,
личный репозиторий имеет вид `https://tinkoff-edu.gitlab.yandexcloud.net/itmo-course-autumn-2023/Students/<username>/Homeworks/HW6`
* Добавить ваше решение в ветку `hw`
* Добавить файл конфигурации `.gitlab-ci.yml` для запуска пайплайна с тестами
* Открыть _Merge request_ из ветки `hw` в ветку `master` **вашего репозитория** (не основного)
* Дождаться, когда пайплайн станет зелёным
* Если будут вопросы по времени сдачи дз &ndash; мы будем ориентироваться на время последнего вашего действия в _Merge request_.

